# 트리 순회 (tree traversal)

- 어떤 트리에서든지 사용할 수 있다 (굳이 이진 트리가 아니어도 상관없음)
- 모든 트리의 노드를 한번씩 방문하는 방법은? -> 2가지 방법
  - Breadth-first-Search
  - Depth-first-Search

```js
//        10
//      6    15
//   3   8       20
```

- 방법 1. BFS (너비 우선 탐색)
  - 트리를 가로질러서 동작이 진행 (형제 노드끼리 수평으로 움직임)
- 방법2. DFS (깊이 우선 탐색)
  - 트리를 수직으로 내려갔다가 다시 올라옴
  - 3가지 방법이 있음

## 1. BFS 너비 우선 탐색

```js
//        10
//      6    15
//   3   8       20
```

10 -> 6 -> 15 -> 3 -> 8 -> 20 순으로 나아감

### 1-1. BFS 구현 (반복문 사용) : 방문한 노드가 담긴 배열 리턴
- 큐 생성 (배열도 가능) 및 방문한 노드 저장할 변수 생성
- 루트 노드를 큐에 배치한다
- 큐에 값이 있을동안 아래를 반복한다
  - 큐에서 노드를 dequeue하고 노드의 값을 마지막에 출력할 변수(배열)에 저장
  - dequeue된 노드에 왼쪽 값이 있는지 확인하고 있으면 큐에 넣는다
  - dequeue된 노드에 오른쪽 값이 있는지 확인하고 있으면 큐에 넣는다
- 루프가 끝나면 모든 값을 저장한 변수를 리턴

## 2. DFS 깊이 우선 탐색
```js
//        10
//      6    15
//   3   8       20
```
- 3가지 탐색으로 나눌 수 있음
  - 전위 탐색 : [10, 6, 3, 8, 15, 20] 
  - 후위 탐색 : [3, 8, 6, 20, 15, 10]
  - 중위 탐색 : [3, 6, 8, 10, 15, 20]

### 2-1. 전위 탐색 - pre order (재귀함수 사용) : 방문한 노드가 담긴 배열 리턴
- 깊이 상관없이 제일 왼쪽 먼저, 오른쪽은 그 다음
- 방문할 노드 저장할 변수 생성
- 루트 노드를 current 변수에 할당
- 노드를 인수로 받는 helper 함수(traverse) 생성
  - 노드들을 저장할 변수(배열)를 만들고 노드를 push한다
  - 노드에 왼쪽 값이 있으면 헬퍼함수를 재귀호출(왼쪽 노드를 인수로 받음)
  - 노드에 오른쪽 값이 있으면 헬퍼함수를 재귀호출(오른쪽 노드를 인수로 받음)
- data를 리턴

- left를 먼저 leaf까지 순회하며 내려갔다가 right를 순회하며 root로 올라옴

### 2-2. 후위 탐색 - post order
- 깊이 상관없이 제일 왼쪽 먼저, 오른쪽은 그 다음
- 루트에서 시작은 하지만, 자식 노드가 있으면 leaf까지 쭉 내려감
- 자식 노드를 다 돌면 부모 노드로 올라오는데 부모 노드를 바로 확인하지 않고 오른쪽 노드로 내려감
- 오른쪽 노드까지 마저 다 보면, 부모 노드로 올라옴
- 그래서 루트 노드를 가장 마지막에 방문


- 구현 (pre order 에서 helper 함수 내부 data push 순서만 다름)
- 방문할 노드 저장할 변수(data) 생성
- 루트 노드를 current 변수에 할당
- 노드를 인수로 받는 helper 함수(traverse) 생성
  - 노드에 왼쪽 값이 있으면 헬퍼함수를 재귀호출(왼쪽 노드를 인수로 받음)
  - 노드에 오른쪽 값이 있으면 헬퍼함수를 재귀호출(오른쪽 노드를 인수로 받음)
  - 노드값을 data에 push
- current를 인수로 traverse 재귀 호출

### 2-3. 중위 탐색 - in order
- 깊이 상관없이 제일 왼쪽 먼저, 오른쪽은 그 다음
- 루트에서 시작하지만, 자식 노드가 있으면 leaf까지 쭉 내려감
- 제일 왼쪽 leaf 방문후 부모노드 방문, 그 다음 우측 노드 있으면 우측노드 방문
- 후위 탐색과 비슷하지만 우측 노드로 넘어가기 전에 부모노드 방문하는 점이 다름

### 2-4. 전위 vs 후위 vs 중위
- 3가지 DFS는 helper 함수의 일부분만 다르고 나머지는 똑같다
  - 전위 : 방문한 노드를 data 배열에 저장하는 구문이 left 노드 확인, right 노드 확인 앞에 위치
  - 후위 : left, right 노드 뒤에 위치
  - 중위 : left 다음, right 전에 위치

## BFS vs DFS 언제 쓰는가?
- BFS는 큐를 사용하게 된다 (자식노드를 먼저 방문하지 않음)
- 그래서 트리의 Depth가 깊어지면 큐에 필요한 메모리가 증가하게 된다 (공간복잡도 증가)
- 
### 한 쪽으로 치우친 트리
- BFS를 사용하면 큐에 저장할 데이터가 적어서 부담이 덜하다

### 노드가 수평으로 길게 구성된 트리
- BFS를 사용하면 큐에 엄청난 데이터가 들어가야 함
- DFS를 사용하면 leaf까지 한번씩 쓱 훑으면 되서 유리

### 같은점
- 시간 복잡도는 동일 (모든 노드 방문)

### DFS 내부에서 구분
- 용도에 따라 어떤 알고리즘을 쓰라고 규정된 경우는 거의 없다
- 중위 탐색의 경우 오름차순이라는 강점이 있다
