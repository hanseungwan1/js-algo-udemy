# 이진 힙 (Binary Heaps)
- 힙 = 트리의 일종
- 여러가지 힙이 존재한다
- 우선순위 큐를 만들기 위해 쓰인다

## 1. 이진 힙이란?
- 이진 탐색 트리와 흡사하나 몇가지 다른 점이 있다
  - 최대 이진 힙 : 부모 노드는 언제나 자식 노드보다 크다
  - 최소 이진 힙 : 부모 노드는 언제나 자식 노드보다 작다
```js
// 이진 힙이 아닌 경우 -> 이진 탐색 트리는 가능
// 
//        33
//    18     41
//  12  27  39
```

### 1-1. 최대 이진 힙(Max Binary Heap)
- 모든 부모 노드는 최대 2개의 자식 노드를 가진다
- 각각의 부모 노드의 값은 항상 자식 노드의 값보다 크다
- 형제 노드들 끼리는 규칙이 없다 (왼쪽이 클 수도 있고 작을 수도 있다)
- 왼쪽 자식 노드가 먼저 채워지고 나서야 오른쪽 자식 노드가 채워진다 (다음 레벨로 내려가기 전에 자식 노드들이 전부 채워짐)

### 1-2. 최소 이진 힙(Min Binary Heap)
- 최대 이진 힙의 반대

### 1-3. 이진 힙에서 자식 노드, 부모 노드 인덱스 찾는 공식
- 인덱스를 기준으로 트리를 그리면
```js
//               0
//         1          2
//    3       4    5      6
//  7  8   9  10 11 12  13 14
```
- 다음과 같은 공식이 성립한다
  - 왼쪽 노드 인덱스 = 부모노드 인덱스 * 2 + 1
  - 오른쪽 노드 인덱스 = 부모노드 인덱스 * 2 + 2
  - 부모 노드 인덱스 = Math.floor((자식 노드 인덱스 - 1) / 2)
  - 재귀를 활용해서 낮은 depth의 인덱스 구할 수 있다

### 1-4. 메서드 구현

### Insert : 최대 힙에 노드 삽입
- 우선 (배열에) push 후 bubble up을 통해 맞는 자리를 찾아간다
```js
// [41, 39, 33, 18, 27, 12]
//
// 55 노드를 삽입하려고 한다
// 순서를 지키며 일단 빈 곳에 새 노드를 삽입한다
//        41
//   39        33
// 18  27    12   (55)

// 1단계 bubble up
//        41
//   39        55
// 18  27    12   33
//
// 2단계 bubble up
//        55
//   39        41
// 18  27    12   33
```

- bubble up
  - index라는 변수를 생성하고 전체 배열 길이 - 1 만큼을 저장한다 (일단 마지막에 위치하기 때문)
  - parentIndex 변수를 생성하고 Math.floor((index - 1) / 2) 를 저장
  - 새 노드가 부모 노드보다 작을 동안 아래를 반복
    - 부모 노드와 현재 노드를 swap

### ExtractMax : 힙에서 루트 제거하고 최근에 추가된 노드로 교체, 이후 sink down
```js
// 1. 원래 힙
// [41, 39, 33, 18, 27, 12]

//         41
//     39      33
//   18  27   12

// 2. 루트 제거후 최근에 추가된 노드로 교체 -> 쉽게 뽑아낼 값이 이것 뿐임
// [12, 39, 33, 18, 27]

//         12
//     39      33
//   18  27   

// 3. sink down (bubble down 이라고도 함)
// [39, 12, 33, 18, 27]

//         39  -> 12 와 39 swap
//     12      33
//   18  27   

// 반복
// [39, 27, 33, 18, 12]

//         39
//     27      33
//   18  12   <- 27과 12 swap
```

- pseudo code
- 인수는 받지 않는다
- 첫번째 값(루트)과 마지막 값을 swap
- 마지막 값은 pop 처리하고 `리턴`해줌
- 새로운 root는 sink down 하여 정확한 위치를 찾는다
  - parent index는 0(루트)에서 시작한다
  - left child (2 * index + 1)를 찾아 비교한다 (해당 자식 노드가 있는지 확인 필수)
  - right child (2 * index + 2)를 찾아 비교한다 (해당 자식 노드가 있는지 확인 필수)
  - left나 right가 element보다 크면, 둘 중 가장 큰 값으로 swap
  - 이 때 parent index도 업데이트 된다
  - 어떤 child도 element보다 크지 않을 떄까지 loop
- old root를 리턴