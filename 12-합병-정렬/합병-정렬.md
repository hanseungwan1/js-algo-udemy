# 합병 정렬 (Merge Sort)

## Intro

- 이제 배울 심화 정렬들은 버블, 삽입, 선택 정렬보다 어렵지만 더 빠르다
- 지금까지 배운 기본 정렬들은 작은 규모의 데이터에서만 효율적(10만개 원소 이하)
- 앞으로 배울 심화 정렬들은 O(n\*logN)의 더욱 빠른 시간복잡도를 갖는다

## 합병 정렬

- 폰 노이만이 EDVAC 컴퓨터로 1948년 처음 개발
- 분할, 정렬, 합병이 동시 발생
- 숫자 1개가 있는 배열은 정렬되어 있는 점을 활용
- 원소 N개가 있는 배열을 계속 분할하여 1개 단위 배열 N개로 분할
- 그리고 합병과 정렬을 반복

```js
// [3 44 38 5 47 15 36 26]
// [3] [44] [38] [5] [47] [15] [36] [26]
// [3 44] [38] [5] [47] [15] [36] [26]
// [3 44] [5 38] [47] [15] [36] [26]
// [3 5 38 44] [47] [15] [36] [26]
// [3 5 38 44] [15 47] [36] [26]
// [3 5 38 44] [15 47] [26 36]
// [3 5 38 44] [15 26 36 47]
// [3 5 15 26 36 38 44 47]
```

## 배열 합병 로직

- 배열은 정렬되어 있다고 전제함
- 예시

```js
// 이러한 합병 함수가 있다고 가정하면
merge([1, 10, 50], [2, 14, 99, 100]); // [1, 2, 10, 14, 50, 99, 100]
```

- 주어진 2 배열을 하나의 정렬된 배열로 만드는데, 2 배열의 모든 원소가 포함되어 있어야 한다
- 시간복잡도와 공간복잡도는 O(N + M) 으로 작동해야 한다 (2 배열)

## 배열 합병 로직 의사 코드

- 먼저 빈 배열을 만들고, 2개의 각각 배열의 최솟값부터 시작한다
  - i , j 카운트를 사용하고 while문을 사용
- 아직 i, j가 배열 끝에 도달하지 않았다면
  - 1번째 배열의 값이 2번째 배열의 값보다 작으면 1번째 배열의 값을 빈 배열에 넣고 다음 값을 비교

## mergeSort 의사 코드

- 배열을 절반으로 나눠나가기 위해 slice()를 사용
- 최종 배열들의 길이는 1보다 작거나 같아야 함
- 이렇게 작은 배열이 준비되면 작성해놓은 합병 함수를 사용하여 합병

```js
// 10 24 76 73 72 1 9
// L [10 24 76]  // R [73 72 1 9]
// L [10] R [24 76] // L [73 72] R [1 9]
// [10], [24], [76], [73], [72], [1], [9] -> 완성
```

이제 이 배열들이 merge 함수를 통해 합병되면서 정렬된다

## 합병 정렬의 시간 복잡도

- 합병 정렬은 엣지 케이스가 없고 어떤 상태에서든지 같은 효율을 보여준다.
- best : O(n logN)
- average : O(n logN)
- worst : O(n logN)
- 공간복잡도 : O(N)

```js
32
16 16
8 8 8 8
4 4 4 4 4 4 4 4
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

// 분할하는데 32의 경우 5회 걸린다 O(logN)
// 각 분할마다, 합병할 때 O(N) 번 비교한다 -> merge 함수
// 그래서 총 시간 복잡도는 O(n logN)
```
