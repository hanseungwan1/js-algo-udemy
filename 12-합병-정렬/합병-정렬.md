# 합병 정렬 (Merge Sort)

## Intro

- 이제 배울 심화 정렬들은 버블, 삽입, 선택 정렬보다 어렵지만 더 빠르다
- 지금까지 배운 기본 정렬들은 작은 규모의 데이터에서만 효율적(10만개 원소 이하)
- 앞으로 배울 심화 정렬들은 O(n\*logN)의 더욱 빠른 시간복잡도를 갖는다

## 합병 정렬

- 폰 노이만이 EDVAC 컴퓨터로 1948년 처음 개발
- 분할, 정렬, 합병이 동시 발생
- 숫자 1개가 있는 배열은 정렬되어 있는 점을 활용
- 원소 N개가 있는 배열을 계속 분할하여 1개 단위 배열 N개로 분할
- 그리고 합병과 정렬을 반복

```js
// [3 44 38 5 47 15 36 26]
// [3] [44] [38] [5] [47] [15] [36] [26]
// [3 44] [38] [5] [47] [15] [36] [26]
// [3 44] [5 38] [47] [15] [36] [26]
// [3 5 38 44] [47] [15] [36] [26]
// [3 5 38 44] [15 47] [36] [26]
// [3 5 38 44] [15 47] [26 36]
// [3 5 38 44] [15 26 36 47]
// [3 5 15 26 36 38 44 47]
```

## 배열 합병 로직

- 배열은 정렬되어 있다고 전제함
- 예시

```js
// 이러한 합병 함수가 있다고 가정하면
merge([1, 10, 50], [2, 14, 99, 100]); // [1, 2, 10, 14, 50, 99, 100]
```

- 주어진 2 배열을 하나의 정렬된 배열로 만드는데, 2 배열의 모든 원소가 포함되어 있어야 한다
- 시간복잡도와 공간복잡도는 O(N + M) 으로 작동해야 한다 (2 배열)

## 배열 합병 로직 의사 코드

- 먼저 빈 배열을 만들고, 2개의 각각 배열의 최솟값부터 시작한다
- - i , j 카운트를 사용하고 while문을 사용
- 아직 i, j가 배열 끝에 도달하지 않았다면
- - 1번째 배열의 값이 2번째 배열의 값보다 작으면 1번째 배열의 값을 빈 배열에 넣고 다음 값을 비교
