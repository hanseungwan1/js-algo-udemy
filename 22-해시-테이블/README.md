# 해시 테이블 (Hash Tables)
- 해시 맵이라고도 함
- 대부분의 프로그래밍 언어에 기본적으로 내장되어 있음 (자바스크립트 포함)
- 키-밸류 쌍을 저장하는데 쓰임
- 순서(인덱스)를 갖지 않는다
- 배열과 다르게 탐색, 추가, 제거가 매우 빠름
## 1. 해시 테이블을 쓰는 이유
- `속도`가 빨라서 대부분의 프로그래밍 언어에서 애용됨
- 각 언어에서의 해시 테이블이 쓰이는 형태
  - Python : 딕셔너리
  - JS : 객체(String만 키로 사용할 수 있음), 맵
  - Java, Go, Scala : 맵
  - Ruby : 해시
- 사람이 이해하기 쉬운 자료구조
  - colors["syan"] 이 colors["#00FFFF"] 보다 직관적임

## 2. 해시 함수
- 일상생활에서 암호화를 위해 자주 쓰임
- 예시 (Python)
```python
// 자릿수만 같고 숫자는 임의로 입력
hash("hello!")
>>> -6242397176492374478

hash("Hello!")
>>> 8242397176492374478

hash("a")
>>> 8942397176492374478
```

- 대체로 일정한 길이의 숫자가 반환됨

### 2-1. 좋은 해시함수의 조건
- 속도 (상수 시간)
- 다른 인풋들에서 같은 아웃풋을 리턴하면 안됨
  - 하지만 인풋에서 아웃풋을 처리하는 동일한 기준이 있어야함 (크기가 같은 무작위 아웃풋 등)
- 하나의 인풋은 언제나 하나의 아웃풋을 발생시켜야 함 (불확실성이 없어야 함)


- bad cases
```js
// 하는 일이 결국 루프 천번 돌고 뭔가 출력 -> 느려. (상수시간 이어야함)
function slowHash(key) {
  for (let i = 0; i < 10000; i++) {
    console.log("everyday i'm hashing");
  }
  return key[0].charCodeAt();
}

// 정해지지 않은 크기의 입력값을 정해진 크기의 출력값으로 바꿔주는 것은 충족하나
// 모든 입력값을 0으로 바꿔버림
function sameHashedValue(key) {
  return 0;
}

// 일정한 크기의 랜덤 값을 출력하긴 하나
// 매번 출력값이 바뀌는 문제가 있음
function randomHash(key) {
  return Math.floor(Math.random() * 1000);
}
```

### 2-2. 해시 함수 만들기
필요한 task
```js
// 문자열 pink를 받아 0~99 숫자에 배정해준다
hash("pink", 100)

// 문자열을 숫자로 바꾸기
"a".charCodeAt(0); // 97
"hi".charCodeAt(0); // 104
"hi".charCodeAt(1); // 105
"a".charCodeAt(0) - 96; // 1
// 이런 식으로 각 알파벳의 ascii code를 더해서 숫자 출력 가능
```

Hash.js 확인!

### 2-3. 충돌 처리
- 긴 아웃풋을 설정하고, 좋은 해시 함수를 설계한다해도 충돌은 불가피하다
- 충돌을 처리하기 위해 2가지에 집중한다
1. Separate Chaining (개별 체이닝)
- 배열이나 연결 리스트를 활용해 이중 데이터 구조를 쓴다
- 예) index 4에 [[darkblue, #00008b], [salmon, #fa8072]] 를 저장
- darkblue -> 4, salmon -> 4
- 배열을 쓰면 편하지만 2차원 배열 형태가 됨

2. Linear Probing (직선 탐색법)
- 개별 체이닝과 다르게 하나의 자리에 하나만 저장
- 충돌이 발생하면 다음 빈 자리를 찾고 거기에 저장하여 충돌을 방지
- 예) darkblue가 이미 4이므로 salmon은 5에 저장
- 개별 체이닝은 10개 array인 경우 10개보다 더 많이 저장할 수 있지만
- 직선 탐색법은 최대 10개까지밖에 저장 못함