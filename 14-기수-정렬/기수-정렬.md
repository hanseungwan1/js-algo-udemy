# 기수 정렬 (radix sort)
## 비교 정렬 (comparison sort)의 한계
수학적으로, 비교 정렬의 평균 시작 복잡도에는 하한선과 점근선이 있다.

이 수학적인 제약 때문에 비교 정렬은 빨라야 최대 O(nlogn)의 복잡도에 지나지 않는다.

하지만 비교 정렬이 아닌, 다른 방식의 정렬 알고리즘으로 복잡도 한계를 뛰어 넘을 수 있다.

## 기수 정렬
기수 정렬은 원소들 간의 대소 비교를 하지 않는다. 대신, 자릿수를 가린다.

## 작동 원리
```js
// 1556, 4, 3556, 593, 408, 4386, 902, 7, 8157, 86, 9637, 29
// 10진수 이므로 버켓 10개 (0~9)
// 1의 자리부터, 자릿수를 기준으로 버켓에 정렬한다

// 1) 1의 자릿수로 정렬 (차례대로 버켓에 넣는다)
// 0 1   2   3 4 5    6    7   8  9
//     902 593 4     86 9637 408 29 
//                 4386 8157
//                 3556    7
//                 1556

// 이를 바탕으로 재정렬 (같은 버켓이면 먼저 들어간 수가 먼저 나온다)
// 902, 593, 4, 1556, 3556, 4386, 86, 7, 8157, 9637, 408, 29

// 2) 10의 자릿수로 정렬
//  0   1   2     3   4    5    6  7    8    9
// 408      29  9637     8157           86  593
//   7                   3556         4386  
//   4                   1556
// 902

// 정렬
// 902, 4, 7, 408, 29, 9637, 8157, 3556, 1556, 4386, 86, 593

// 3) 100의 자릿수로 정렬
// 0     1    2  3    4    5    6  7    8    9
//  86  8157    4386  408  593 9637          902
//  29                    3556
//   7                    1556
//   4

// 정렬
// 4 7 29 86 8157 4386 408 1556 3556 593 9637 902

// 마지막) 1000의 자릿수로 정렬
// 0     1    2  3     4     5   6  7  8     9
//  902  1556    3556  4386            8157  9637
//  593
//  408
//   86
//   29
//    7
//    4

// 정렬
// 4 7 29 86 408 593 902 1556 3556 4386 8157 9637
```

비교 없이 정렬 완성

## pseudo code
- 수 목록이 파라미터로 들어옴 (10, 183, 43, 3, 8312, 7192, 11, 999)
- 우선 제일 큰 자릿수를 알아냄
- 0부터 제일 큰 자릿수까지 반복하는 loop를 만들고, 다음을 반복
  + 0~9 까지 버킷을 만듬
  + 배열의 순서대로 버킷에 넣고 다시 배열로 환원

## 기수 정렬의 시간복잡도
- n은 배열의 길이, k는 자릿수
- Best: O(nk)
- Average: O(nk)
- Worst: O(nk)
- 공간복잡도: O(n + k)

자릿수의 영향을 크게 받는것을 알 수 있다

그러나 컴퓨터가 숫자 정보를 저장하는 방식 때문에 자연적인 무작위한 데이터상에서는 k가 실제로 log n에 가깝게 된다.

즉, 비교 정렬과 복잡도 차이가 크지 않게 되버리는 것이다.