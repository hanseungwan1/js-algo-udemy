# 단일 연결 리스트 (Singly Linked List)
배열에 비해 삽입, 삭제가 빠른 장점이 있다
## 특징
- 링크드 리스트에는 배열같은 인덱스가 없다
- 데이터들이 열차처럼 연결되어 있기 때문에, 5번째 값을 찾으려면 1번째부터 하나하나 세어야 한다.
- 각각의 엘리먼트를 노드라고 한다
## 핵심 요소
- 노드들은 모두 다음값에 대한 정보(pointer)를 갖는다. 그래서 현재값에서 다음값으로 찾아갈 수 있다
- `단일 연결 리스트`는 각 노드가 다음 노드로 단일 방향으로만 연결되어 있다
- HEAD : 링크드 리스트의 시작점
- TAIL : 링크드 리스트의 종료점 (next 값이 null)
- LENGTH : 링크드 리스트의 길이
## vs 배열
### 연결 리스트
- 인덱스가 없다
- next pointer 를 통해 노드들이 연결된다
- 특정값에 직접 접근이 불가능하다
### 배열
- 순서대로(인덱스) 정렬된다
- 값 삽입과 삭제가 비교적 오래 걸린다
- 특정 인덱스의 값에 빠르게 접근할 수 있다

## 메서드
### push() : 리스트 맨 뒤에 새로운 노드 추가
- value 를 받아들여 새로운 노드를 만든다
- 해드가 없다면 빈 리스트이기 때문에 head 와 tail 이 1번째 값을 가리키게 하면 된다
- 값을 추가할 때마다 tail 이 새로운 값을 가리키게 한다
- length 를 1 증가시켜준다
- 그리고 update 된 리스트를 반환한다

### pop() : 리스트 맨 뒤 노드를 제거
- 현재 리스트에 아무 값도 없다면 undefined 를 반환
- tail 에 도달할 때까지 리스트를 하나씩 거쳐간다
- 현재 tail (마지막 노드)을 제거
    + 마지막 전 노드의 next 를 null로 만듬
    + 이 노드를 tail로 만듬
- length 를 1 감소시킴
- 삭제된 node 를 반환

### shift() : 리스트 맨 앞 노드를 제거
- 배열과 다르게 O(1)의 복잡도
- 삭제된 node 를 반환
- 빈 리스트일 경우 undefined 를 반환
- 현재 head 다음 노드를 head 로 만듬
- 현재 head 의 next 를 null 로 만듬
- length 1 감소
- 삭제된 값 리턴

### unshift() : 리스트 맨 앞 노드를 추가
- 배열과 다르게 O(1)의 복잡도
- 최종 리스트를 반환

### get(idx) : idx에 해당하는 노드 반환
- get(0) 은 head를 반환
- idx 만큼 리스트를 따라간 후 해당 위치의 노드를 반환
- 범위를 초과하는 숫자를 입력받은 경우 null을 반환

### set(idx, val) : 특정 인덱스의 노드 값을 변경
- 특정 인덱스의 값을 찾기 위해 앞서 구현한 get 메서드를 활용
- index의 노드가 존재하지 않으면 false 반환
- 값 변경에 성공하면 true 반환

### insert(idx, val) : 특정 인덱스에 노드를 삽입
- 리스트 범위를 초과하는 숫자를 입력받은 경우 false 반환
- push, unshift 와 다르게 리스트 중간에 삽입
- 삽입할 새로운 노드 생성
- 먼저 타겟 인덱스 이전 노드의 next를 삽입할 노드에 연결
- 추가한 노드의 next에 원래 노드를 이어줌
- idx가 0이면 unshift, this.length 이면 push 활용
- 길이를 +1 증가하고 true 반환

### remove(idx) : 특정 인덱스의 노드를 제거
- insert의 반대 개념
- idx 가 0이면 shift, this.length - 1이면 pop 활용
- 리스트 범위를 초과하는 숫자를 입력받은 경우 undefined 반환
- 제거된 값을 반환

### reverse() : 리스트 내 노드의 순서를 바꿈
- head 와 tail 을 바꾼다
- next, prev, current 변수를 생성하고 current에 tail (원래 head 이었던 노드)를 할당한다
- 리스트를 순회하면서 값 할당

## 시간 복잡도
- 삽입 : O(1)
- 제거 : shift : O(1) ~ pop : O(N)
- 탐색 : O(N) : 예) 99 값이 있는지 탐색할 때
- 접근 : get : O(N)
- 삽입과 삭제의 경우 배열에 비해 빠르다
- 탐색, 접근의 경우 배열에 비해 느리다

## 정리
- 링크드 리스트는 삽입, 제거가 빈번히 일어날 때 효과적이다
- 인덱스를 갖지 않기 때문에 탐색이나 접근은 배열보다 느리다