# 트리
## 1. 트리 소개
- 일반 트리, 이진 트리, 이진 탐색 트리(Binary Search Trees) 등 종류가 있다
- 이진 탐색 트리가 핵심
- 노드로 이루어지며 parent-child 관계를 갖는다
  - 부모 노드는 자식 노드 만을 가리킬 수 있다 (동일 수준의 노드 가리킬 수 없음)
- 비선형(non-linear) 자료구조 (선형 자료구조 : 리스트)
- 시작지점(entry point)이 단 하나여야 한다 -> 루트

### 1-1. 용어 정리
- Root : 최상위 노드
- Child : Root에서 내려와 다른 노드로부터 연결된 노드
- Parent : Child의 상위 노드
- Siblings : 같은 Parent를 가진 노드
- Leaf : Child가 없는 노드
- Edge (간선) : 한 노드와 다른 노드 간의 연결

### 1-2. 트리 활용
- HTML DOM : DOM Tree 구조를 가짐
- 네트워크 라우팅
- 추상구문트리 (Abstract Syntax Tree) : 프로그래밍 언어의 구문을 설명
- 인공지능
- 파일 시스템의 디렉토리 구조

## 2. 이진 트리 (Binary Tree) 와 이진 탐색 트리(BST)
- 이진 트리 : 부모 노드가 최대 2개까지만 자식 노드를 가지는 트리 구조
- 이진 탐색 트리 : 탐색에 강점을 보이는 이진 트리로, 데이터를 비교해서 정렬 가능하게 저장
  - 값들은 모두 unique 해야한다 (중복 금지)
  - 부모 노드의 왼쪽 자식 노드는 부모 노드보다 작고
  - 부모 노드의 오른쪽 자식 노드는 부모 노드보다 크다
```js
// 이진 탐색 트리

//        10
//      /   \
//     6    15
//   /  \     \
//  3   8     20
```

### 2-1. 이진 탐색 트리의 탐색 과정
아래 이진탐색트리에서 72를 찾아나가는 과정은 어떻게 될까?
```js
//             41
//        /          \
//     20             65
//   /    \         /    \
//  11    29     50       91
//    \     \           /    \
//     12   32        72      99
```
1. 72는 41보다 큰가? (O) -> 우측 자식 노드(65)로 이동 (좌측 절반 날아감) -> 이진 탐색과 유사
2. 72는 65보다 큰가? (O) -> 우측 자식 노드(91)로 이동
3. 72는 91보다 큰가> (X) -> 좌측 자식 노드(71)로 이동 -> 소요된 연산 : 3회

## 3. 이진 탐색 트리 구현

### insert : 새 노드를 생성하고 트리에 추가하고 트리를 반환
반복 or 재귀 중에 한 방법을 사용할 수 있다
   
- 노드를 생성한다
  - root 노드가 없으면, 새 노드가 root가 된다
  - root 노드가 있으면, 새 노드값과 대소 비교
    - 새 노드가 root 노드보다 크면, root 우측 노드가 있는지 확인하고
      - 없으면 우측 노드에 위치
      - 있으면 대소 비교를 실시
    - 새 노드가 root 노드보다 작으면, root 좌측 노드가 있는지 확인하고
      - 없으면 좌측 노드에 위치
      - 있으면 대소 비교를 실시

### find : value값을 입력받아 해당 값이 트리에 있으면 true, 없으면 false를 반환
반복 or 재귀 중에 한 방법을 사용할 수 있다  

- root가 없으면 탐색 종료
  - 루트가 있으면 값을 비교
    - 찾던 값이면 탐색 종료
    - 아니면 대소 비교
      - 새 노드값이 루트값보다 크면 우측 노드 있는지 확인
        - 우측 노드 없으면 탐색 종료
        - 우측 노드 있으면 우측 노드로 이동해 대소 비교
      - 새 노드 값이 루트값보다 작으면 좌측 노드 있는지 확인
        - 좌측 노드 없으면 탐색 종료
        - 좌측 노드 있으면 좌측 노드로 이동해 대소 비교

## 4. 이진 탐색 트리의 시간복잡도
- 삽입 : O(log n) -> best, average
- 탐색 : O(log n)
- log n 의 시간복잡도는 매우 우수한 편이다!
- 하지만 worst case도 존재한다
  - 예) 3 - 17 - 19 - 32 - 34 - ... 처럼 한 방향으로만 늘어지는 형태
  - 복잡도가 깊이만큼 증가 : O(N)